SUBDESIGN attempts
(	enable, clock, clearn						:INPUT;
	lsd_disp[6..0], msd_disp[6..0], game_over			:OUTPUT;)
VARIABLE
		lsd[3..0], msd[3..0]			:DFF;
		game_over						:DFF;
BEGIN
game_over.clk = clock;
game_over.clrn = clearn;
game_over.d = lsd[] == 9 & msd[] == 9;
lsd[].clrn = clearn;
msd[].clrn = clearn;
lsd[].clk = clock;
msd[].clk = clock;
	IF enable == 0	THEN
			lsd[].d = lsd[].q;
	ELSIF lsd[].q < 9 THEN	
			lsd[].d = lsd[].q + 1;
	ELSE 
			lsd[].d = 0;
	END IF;
	
	IF !enable # lsd[].q != 9 THEN
		msd[].d = msd[].q;
	ELSIF msd[].q < 9 THEN	
			msd[].d = msd[].q + 1;
	ELSE 
			msd[].d = 0;
	END IF;	
--	score[] = bcd[].q;
	
		TABLE						-- convert Binary to 7-seg patterns
		lsd[].q	=>		lsd_disp[];	
		0			=>		(1,0,0,0,0,0,0);	-- 0   displays a 7-segment pattern for 0 (segments a-f on)
		1			=>		(1,1,1,1,0,0,1);
		2			=>		(0,1,0,0,1,0,0);
		3			=>		(0,1,1,0,0,0,0);
		4			=>		(0,0,1,1,0,0,1);
		5			=>		(0,0,1,0,0,1,0);
		6			=>		(0,0,0,0,0,1,0);
		7			=>		(1,1,1,1,0,0,0);
		8			=>		(0,0,0,0,0,0,0);
		9			=>		(0,0,1,1,0,0,0);
		10			=>		(0,0,0,1,0,0,0);	-- A
		11			=>		(0,0,0,0,0,1,1);	-- B
		12			=>		(1,0,0,0,1,1,0);	-- C
		13			=> 	(0,1,0,0,0,0,1);
		14			=> 	(0,0,0,0,1,1,0);
		15			=>		(0,0,0,1,1,1,0);	-- F
	END TABLE;	
	TABLE						-- convert Binary to 7-seg patterns
		msd[].q	=>		msd_disp[];	
		0			=>		(1,0,0,0,0,0,0);	-- 0   displays a 7-segment pattern for 0 (segments a-f on)
		1			=>		(1,1,1,1,0,0,1);
		2			=>		(0,1,0,0,1,0,0);
		3			=>		(0,1,1,0,0,0,0);
		4			=>		(0,0,1,1,0,0,1);
		5			=>		(0,0,1,0,0,1,0);
		6			=>		(0,0,0,0,0,1,0);
		7			=>		(1,1,1,1,0,0,0);
		8			=>		(0,0,0,0,0,0,0);
		9			=>		(0,0,1,1,0,0,0);
		10			=>		(0,0,0,1,0,0,0);	-- A
		11			=>		(0,0,0,0,0,1,1);	-- B
		12			=>		(1,0,0,0,1,1,0);	-- C
		13			=> 	(0,1,0,0,0,0,1);
		14			=> 	(0,0,0,0,1,1,0);
		15			=>		(0,0,0,1,1,1,0);	-- F
	END TABLE;	
END;